-- Create table to track deleted apps for billing
CREATE TABLE IF NOT EXISTS "public"."deleted_apps" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "created_at" timestamp with time zone DEFAULT now(),
    "app_id" character varying NOT NULL,
    "owner_org" uuid NOT NULL,
    "deleted_at" timestamp with time zone DEFAULT now()
);

-- Add unique constraint to existing table
ALTER TABLE "public"."deleted_apps" 
ADD CONSTRAINT deleted_apps_app_id_owner_org_key 
UNIQUE (app_id, owner_org);

-- Enable RLS
ALTER TABLE "public"."deleted_apps" ENABLE ROW LEVEL SECURITY;

-- Create policies to deny all access
CREATE POLICY "deny_all_access" ON "public"."deleted_apps"
    FOR ALL
    USING (false)
    WITH CHECK (false);

-- Add indexes for deleted_apps
CREATE INDEX IF NOT EXISTS idx_deleted_apps_app_id ON "public"."deleted_apps" (app_id);
CREATE INDEX IF NOT EXISTS idx_deleted_apps_owner_org ON "public"."deleted_apps" (owner_org);
CREATE INDEX IF NOT EXISTS idx_deleted_apps_deleted_at ON "public"."deleted_apps" (deleted_at);

-- Create trigger for app deletion
DROP TRIGGER IF EXISTS "on_app_delete" ON "public"."apps";
CREATE TRIGGER "on_app_delete"
  AFTER DELETE ON "public"."apps"
  FOR EACH ROW
  EXECUTE FUNCTION "public"."trigger_http_queue_post_to_function"('on_app_delete');

-- Create queue for app deletion
SELECT pgmq.create('on_app_delete');

SELECT cron.schedule(
    'process_app_delete_queue',
    '5 seconds',
    $$SELECT process_function_queue('on_app_delete');$$
);

-- Create function to delete old records
CREATE OR REPLACE FUNCTION "public"."delete_old_deleted_apps"()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    DELETE FROM "public"."deleted_apps"
    WHERE deleted_at < NOW() - INTERVAL '35 days';
END;
$$;

-- Schedule deletion of old records
SELECT cron.schedule(
    'delete_old_deleted_apps',
    '0 0 * * *', -- Run at midnight every day
    $$SELECT delete_old_deleted_apps();$$
);

-- Create function to get metrics including deleted apps
CREATE OR REPLACE FUNCTION "public"."get_app_metrics"(
    org_id uuid,
    start_date date,
    end_date date
)
RETURNS TABLE (
    app_id character varying,
    date date,
    mau bigint,
    storage bigint,
    bandwidth bigint,
    get bigint,
    fail bigint,
    install bigint,
    uninstall bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    WITH DateSeries AS (
        SELECT generate_series(start_date, end_date, '1 day'::interval)::date AS "date"
    ),
    all_apps AS (
        -- Get active apps
        SELECT apps.app_id, apps.owner_org
        FROM apps
        WHERE apps.owner_org = org_id
        UNION
        -- Get deleted apps
        SELECT deleted_apps.app_id, deleted_apps.owner_org
        FROM deleted_apps
        WHERE deleted_apps.owner_org = org_id
    ),
    deleted_metrics AS (
        SELECT 
            deleted_apps.app_id,
            deleted_apps.deleted_at::date as date,
            COUNT(*) as deleted_count
        FROM deleted_apps
        WHERE deleted_apps.owner_org = org_id
        AND deleted_apps.deleted_at::date BETWEEN start_date AND end_date
        GROUP BY deleted_apps.app_id, deleted_apps.deleted_at::date
    )
    SELECT
        aa.app_id,
        ds.date::date,
        COALESCE(dm.mau, 0) AS mau,
        COALESCE(dst.storage, 0) AS storage,
        COALESCE(db.bandwidth, 0) AS bandwidth,
        COALESCE(SUM(dv.get)::bigint, 0) AS get,
        COALESCE(SUM(dv.fail)::bigint, 0) AS fail,
        COALESCE(SUM(dv.install)::bigint, 0) AS install,
        COALESCE(SUM(dv.uninstall)::bigint, 0) AS uninstall
    FROM 
        all_apps aa
    CROSS JOIN 
        DateSeries ds
    LEFT JOIN 
        daily_mau dm ON aa.app_id = dm.app_id AND ds.date = dm.date
    LEFT JOIN 
        daily_storage dst ON aa.app_id = dst.app_id AND ds.date = dst.date
    LEFT JOIN 
        daily_bandwidth db ON aa.app_id = db.app_id AND ds.date = db.date
    LEFT JOIN 
        daily_version dv ON aa.app_id = dv.app_id AND ds.date = dv.date
    LEFT JOIN
        deleted_metrics del ON aa.app_id = del.app_id AND ds.date = del.date
    GROUP BY 
        aa.app_id, ds.date, dm.mau, dst.storage, db.bandwidth, del.deleted_count
    ORDER BY
        aa.app_id, ds.date;
END;
$$;
