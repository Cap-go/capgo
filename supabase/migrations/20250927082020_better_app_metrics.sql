CREATE TABLE IF NOT EXISTS public.app_metrics_cache (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    org_id uuid NOT NULL REFERENCES public.orgs (id),
    start_date date NOT NULL,
    end_date date NOT NULL,
    response jsonb NOT NULL,
    cached_at timestamp with time zone NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX IF NOT EXISTS app_metrics_cache_org_id_key ON public.app_metrics_cache (
    org_id
);

ALTER TABLE public.app_metrics_cache ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Deny all" ON public.app_metrics_cache FOR ALL USING (false)
WITH
CHECK (false);

CREATE OR REPLACE FUNCTION public.seed_get_app_metrics_caches(
    p_org_id uuid, p_start_date date, p_end_date date
) RETURNS public.app_metrics_cache LANGUAGE plpgsql SECURITY DEFINER
SET
search_path TO '' AS $function$
DECLARE
    metrics_json jsonb;
    cache_record public.app_metrics_cache%ROWTYPE;
BEGIN
    WITH DateSeries AS (
        SELECT generate_series(p_start_date, p_end_date, '1 day'::interval)::date AS date
    ),
    all_apps AS (
        SELECT apps.app_id, apps.owner_org
        FROM public.apps
        WHERE apps.owner_org = p_org_id
        UNION
        SELECT deleted_apps.app_id, deleted_apps.owner_org
        FROM public.deleted_apps
        WHERE deleted_apps.owner_org = p_org_id
    ),
    deleted_metrics AS (
        SELECT 
            deleted_apps.app_id,
            deleted_apps.deleted_at::date AS date,
            COUNT(*) AS deleted_count
        FROM public.deleted_apps
        WHERE deleted_apps.owner_org = p_org_id
        AND deleted_apps.deleted_at::date BETWEEN p_start_date AND p_end_date
        GROUP BY deleted_apps.app_id, deleted_apps.deleted_at::date
    ),
    metrics AS (
        SELECT
            aa.app_id,
            ds.date::date,
            COALESCE(dm.mau, 0) AS mau,
            COALESCE(dst.storage, 0) AS storage,
            COALESCE(db.bandwidth, 0) AS bandwidth,
            COALESCE(SUM(dv.get)::bigint, 0) AS get,
            COALESCE(SUM(dv.fail)::bigint, 0) AS fail,
            COALESCE(SUM(dv.install)::bigint, 0) AS install,
            COALESCE(SUM(dv.uninstall)::bigint, 0) AS uninstall
        FROM
            all_apps aa
        CROSS JOIN 
            DateSeries ds
        LEFT JOIN 
            public.daily_mau dm ON aa.app_id = dm.app_id AND ds.date = dm.date
        LEFT JOIN 
            public.daily_storage dst ON aa.app_id = dst.app_id AND ds.date = dst.date
        LEFT JOIN 
            public.daily_bandwidth db ON aa.app_id = db.app_id AND ds.date = db.date
        LEFT JOIN 
            public.daily_version dv ON aa.app_id = dv.app_id AND ds.date = dv.date
        LEFT JOIN
            deleted_metrics del ON aa.app_id = del.app_id AND ds.date = del.date
        GROUP BY 
            aa.app_id, ds.date, dm.mau, dst.storage, db.bandwidth, del.deleted_count
    )
    SELECT COALESCE(
        jsonb_agg(row_to_json(metrics) ORDER BY metrics.app_id, metrics.date),
        '[]'::jsonb
    )
    INTO metrics_json
    FROM metrics;

    INSERT INTO public.app_metrics_cache (org_id, start_date, end_date, response, cached_at)
    VALUES (p_org_id, p_start_date, p_end_date, metrics_json, clock_timestamp())
    ON CONFLICT (org_id) DO UPDATE
        SET start_date = EXCLUDED.start_date,
            end_date = EXCLUDED.end_date,
            response = EXCLUDED.response,
            cached_at = EXCLUDED.cached_at
    RETURNING * INTO cache_record;

    RETURN cache_record;
END;
$function$;

REVOKE ALL ON FUNCTION public.seed_get_app_metrics_caches(uuid, date, date)
FROM
public;

REVOKE ALL ON FUNCTION public.seed_get_app_metrics_caches(uuid, date, date)
FROM
anon;

REVOKE ALL ON FUNCTION public.seed_get_app_metrics_caches(uuid, date, date)
FROM
authenticated;

REVOKE ALL ON FUNCTION public.seed_get_app_metrics_caches(uuid, date, date)
FROM
service_role;

CREATE OR REPLACE FUNCTION public.get_app_metrics(org_id uuid) RETURNS TABLE (
    app_id character varying,
    date date,
    mau bigint,
    storage bigint,
    bandwidth bigint,
    get bigint,
    fail bigint,
    install bigint,
    uninstall bigint
) LANGUAGE plpgsql
SET
search_path TO '' AS $function$
DECLARE
    cycle_start timestamp with time zone;
    cycle_end timestamp with time zone;
BEGIN
    SELECT subscription_anchor_start, subscription_anchor_end 
    INTO cycle_start, cycle_end
    FROM public.get_cycle_info_org(org_id);
    
    RETURN QUERY
    SELECT * FROM public.get_app_metrics(org_id, cycle_start::date, cycle_end::date);
END;
$function$;

REVOKE
EXECUTE ON FUNCTION public.get_app_metrics(org_id uuid)
FROM
public,
anon,
authenticated;

GRANT
EXECUTE ON FUNCTION public.get_app_metrics(org_id uuid) TO service_role;

DROP FUNCTION IF EXISTS public.get_app_metrics(
    org_id uuid, start_date date, end_date date
);

CREATE OR REPLACE FUNCTION public.get_app_metrics(
    p_org_id uuid, p_start_date date, p_end_date date
) RETURNS TABLE (
    app_id character varying,
    date date,
    mau bigint,
    storage bigint,
    bandwidth bigint,
    get bigint,
    fail bigint,
    install bigint,
    uninstall bigint
) LANGUAGE plpgsql SECURITY DEFINER
SET
search_path TO '' AS $function$
DECLARE
    cache_entry public.app_metrics_cache%ROWTYPE;
    org_exists boolean;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM public.orgs WHERE id = p_org_id
    ) INTO org_exists;

    IF NOT org_exists THEN
        RETURN;
    END IF;

    SELECT *
    INTO cache_entry
    FROM public.app_metrics_cache
    WHERE org_id = p_org_id;

    IF cache_entry.id IS NULL
        OR cache_entry.start_date IS DISTINCT FROM p_start_date
        OR cache_entry.end_date IS DISTINCT FROM p_end_date
        OR cache_entry.cached_at IS NULL
        OR cache_entry.cached_at < (now() - interval '5 minutes') THEN
        cache_entry := public.seed_get_app_metrics_caches(p_org_id, p_start_date, p_end_date);
    END IF;

    IF cache_entry.response IS NULL THEN
        RETURN;
    END IF;

    RETURN QUERY
    SELECT
        metrics.app_id,
        metrics.date,
        metrics.mau,
        metrics.storage,
        metrics.bandwidth,
        metrics.get,
        metrics.fail,
        metrics.install,
        metrics.uninstall
    FROM jsonb_to_recordset(cache_entry.response) AS metrics(
        app_id character varying,
        date date,
        mau bigint,
        storage bigint,
        bandwidth bigint,
        get bigint,
        fail bigint,
        install bigint,
        uninstall bigint
    )
    ORDER BY metrics.app_id, metrics.date;
END;
$function$;

REVOKE
EXECUTE ON FUNCTION public.get_app_metrics(uuid, date, date)
FROM
public,
anon,
authenticated;

GRANT
EXECUTE ON FUNCTION public.get_app_metrics(uuid, date, date) TO service_role;

ALTER FUNCTION public.get_app_metrics(
    "org_id" uuid,
    "start_date" date,
    "end_date" date
) OWNER TO "postgres";
