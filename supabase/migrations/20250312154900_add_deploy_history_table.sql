-- Add link and comment fields to app_versions table
ALTER TABLE app_versions 
ADD COLUMN IF NOT EXISTS link text,
ADD COLUMN IF NOT EXISTS comment text;

-- Create deploy_history table with indexes for performance
CREATE TABLE IF NOT EXISTS deploy_history (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  version_id BIGINT NOT NULL REFERENCES app_versions(id) ON DELETE CASCADE,
  app_id TEXT NOT NULL REFERENCES apps(app_id) ON DELETE CASCADE,
  channel_id BIGINT NOT NULL REFERENCES channels(id) ON DELETE CASCADE,
  deployed_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  link TEXT,
  comment TEXT,
  is_current BOOLEAN DEFAULT TRUE,
  owner_org TEXT NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Update reset_app_data function to handle deploy_history table
CREATE OR REPLACE FUNCTION "public"."reset_app_data"("p_app_id" character varying) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    max_version_id bigint;
    max_channel_id bigint;
BEGIN
    -- Delete from deploy_history table first (new table)
    DELETE FROM deploy_history WHERE app_id = p_app_id;
    
    -- Delete existing data for the specified app_id (original functionality)
    DELETE FROM channels WHERE app_id = p_app_id;
    DELETE FROM app_versions WHERE app_id = p_app_id;
    DELETE FROM apps WHERE app_id = p_app_id;

    -- Get the current max ids and reset the sequences (original functionality)
    SELECT COALESCE(MAX(id), 0) + 1 INTO max_version_id FROM app_versions;
    SELECT COALESCE(MAX(id), 0) + 1 INTO max_channel_id FROM channels;
    
    -- Reset both sequences (original functionality)
    PERFORM setval('app_versions_id_seq', max_version_id, false);
    PERFORM setval('channel_id_seq', max_channel_id, false);
END;
$$;

-- Restore function permissions
ALTER FUNCTION "public"."reset_app_data"("p_app_id" character varying) OWNER TO "postgres";
REVOKE ALL ON FUNCTION "public"."reset_app_data"("p_app_id" character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."reset_app_data"("p_app_id" character varying) TO "service_role";

-- Add indexes for improved query performance
CREATE INDEX IF NOT EXISTS deploy_history_app_id_idx ON deploy_history(app_id);
CREATE INDEX IF NOT EXISTS deploy_history_channel_id_idx ON deploy_history(channel_id);
CREATE INDEX IF NOT EXISTS deploy_history_version_id_idx ON deploy_history(version_id);
CREATE INDEX IF NOT EXISTS deploy_history_is_current_idx ON deploy_history(is_current);
CREATE INDEX IF NOT EXISTS deploy_history_deployed_at_idx ON deploy_history(deployed_at);

-- Create trigger function to record deployment history
CREATE OR REPLACE FUNCTION record_deployment_history()
RETURNS TRIGGER AS $$
BEGIN
  -- Only update records with is_current=TRUE to improve performance
  UPDATE deploy_history
  SET is_current = FALSE
  WHERE channel_id = NEW.id 
    AND app_id = NEW.app_id 
    AND is_current = TRUE;
  
  -- Insert new record
  INSERT INTO deploy_history (
    version_id,
    app_id,
    channel_id,
    owner_org,
    link,
    comment
  )
  SELECT
    NEW.version,
    NEW.app_id,
    NEW.id,
    NEW.owner_org,
    v.link,
    v.comment
  FROM app_versions v
  WHERE v.id = NEW.version;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to record deployment history when channel version changes
DROP TRIGGER IF EXISTS record_channel_deployment_history ON channels;
CREATE TRIGGER record_channel_deployment_history
AFTER UPDATE OF version ON channels
FOR EACH ROW
WHEN (OLD.version IS DISTINCT FROM NEW.version)
EXECUTE FUNCTION record_deployment_history();
