CREATE TABLE
  public.orgs (
    id uuid NOT NULL,
    created_by uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    logo text NULL,
    name text NOT NULL,
    customer_id character varying,
    constraint orgs_pkey primary key (id)
  );

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.orgs FOR EACH ROW EXECUTE FUNCTION extensions.moddatetime('updated_at');

CREATE TYPE user_min_right AS ENUM ('read', 'upload', 'write', 'admin');

CREATE TABLE
  public.org_users (
    id bigint generated by default as identity not null,
    created_at timestamp with time zone null default now(),
    updated_at timestamp with time zone null default now(),
    user_id uuid not null,
    user_right public.user_min_right not null default 'read'::user_min_right,
    org_id uuid not null,
    app_id character varying null,
    channel_id bigint null,
    constraint org_users_pkey primary key (id),
    constraint org_users_app_id_fkey foreign key (app_id) references apps (app_id) on delete cascade,
    constraint org_users_channel_id_fkey foreign key (channel_id) references channels (id) on delete cascade,
    constraint org_users_org_id_fkey foreign key (org_id) references orgs (id) on delete cascade,
    constraint org_users_user_id_fkey foreign key (user_id) references users (id) on delete cascade
  );

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.org_users FOR EACH ROW EXECUTE FUNCTION extensions.moddatetime('updated_at');

-- create default org for all users
INSERT INTO public.orgs (id, created_by, name)
SELECT uuid_generate_v4(), id, COALESCE(first_name, 'Default Organization')
FROM public.users;

-- update orgs name to include 'Organization'
UPDATE public.orgs 
SET name = CONCAT(name, ' Organization')
WHERE name NOT LIKE '%Organization';

-- Add all users to org_users for they own org
INSERT INTO public.org_users (user_id, org_id, user_right)
SELECT users.id, orgs.id, 'admin'::user_min_right
FROM public.users
INNER JOIN public.orgs ON public.users.id = public.orgs.created_by;

-- Add old channel users to org_users
DO
$$
DECLARE
    rec record;
    org_id uuid;
BEGIN
    FOR rec IN SELECT * FROM channel_users
    LOOP
        -- Step 2 and 3: get the org id using app id and user id
        WITH app AS (
            SELECT * 
            FROM apps
            WHERE app_id = rec.app_id
        )
        SELECT orgs.id 
        INTO org_id 
        FROM orgs, app
        WHERE orgs.created_by = app.user_id;

        -- Step 4: create new row in org_users with 'read' right
        INSERT INTO org_users (user_id, org_id, app_id, channel_id, user_right) 
        VALUES (rec.user_id, org_id, rec.app_id, rec.channel_id, 'read');
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- add function to check if user has min right
CREATE OR REPLACE FUNCTION check_min_rights(min_right user_min_right, user_id uuid, org_id uuid, app_id varchar, channel_id bigint)
RETURNS boolean AS $$
DECLARE
    user_right_record RECORD;
BEGIN
    FOR user_right_record IN 
        SELECT org_users.user_right, org_users.app_id, org_users.channel_id 
        FROM org_users 
        WHERE org_users.org_id = check_min_rights.org_id AND org_users.user_id = check_min_rights.user_id
    LOOP
        IF (user_right_record.user_right >= min_right AND user_right_record.app_id IS NULL AND user_right_record.channel_id IS NULL) OR
           (user_right_record.user_right >= min_right AND user_right_record.app_id = check_min_rights.app_id AND user_right_record.channel_id IS NULL) OR
           (user_right_record.user_right >= min_right AND user_right_record.app_id = check_min_rights.app_id AND user_right_record.channel_id = check_min_rights.channel_id)
        THEN
            RETURN true;
        END IF;
    END LOOP;

    RETURN false;
END;
$$ LANGUAGE plpgsql;
