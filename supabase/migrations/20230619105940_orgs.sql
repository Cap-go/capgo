-- CREATE TABLE
--   public.orgs (
--     id uuid NOT NULL,
--     created_by uuid NOT NULL,
--     created_at timestamp with time zone DEFAULT now(),
--     updated_at timestamp with time zone DEFAULT now(),
--     logo text NULL,
--     name text NOT NULL,
--     customer_id character varying,
--     constraint orgs_pkey primary key (id)
--   );

-- CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.orgs FOR EACH ROW EXECUTE FUNCTION extensions.moddatetime('updated_at');

-- CREATE TYPE user_min_right AS ENUM ('read', 'upload', 'write', 'admin');

-- CREATE TABLE
--   public.org_users (
--     id bigint generated by default as identity not null,
--     created_at timestamp with time zone null default now(),
--     updated_at timestamp with time zone null default now(),
--     user_id uuid not null,
--     user_right public.user_min_right not null default 'read'::user_min_right,
--     org_id uuid not null,
--     app_id character varying null,
--     channel_id bigint null,
--     constraint org_users_pkey primary key (id),
--     constraint org_users_app_id_fkey foreign key (app_id) references apps (app_id) on delete cascade,
--     constraint org_users_channel_id_fkey foreign key (channel_id) references channels (id) on delete cascade,
--     constraint org_users_org_id_fkey foreign key (org_id) references orgs (id) on delete cascade,
--     constraint org_users_user_id_fkey foreign key (user_id) references users (id) on delete cascade
--   );

-- CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.org_users FOR EACH ROW EXECUTE FUNCTION extensions.moddatetime('updated_at');

-- -- create default org for all users
-- INSERT INTO public.orgs (id, created_by, name)
-- SELECT uuid_generate_v4(), id, COALESCE(first_name, 'Default Organization')
-- FROM public.users;

-- -- update orgs name to include 'Organization'
-- UPDATE public.orgs 
-- SET name = CONCAT(name, ' Organization')
-- WHERE name NOT LIKE '%Organization';

-- -- Add all users to org_users for they own org
-- INSERT INTO public.org_users (user_id, org_id, user_right)
-- SELECT users.id, orgs.id, 'admin'::user_min_right
-- FROM public.users
-- INNER JOIN public.orgs ON public.users.id = public.orgs.created_by;

-- -- Add old channel users to org_users
-- DO
-- $$
-- DECLARE
--     rec record;
--     org_id uuid;
-- BEGIN
--     FOR rec IN SELECT * FROM channel_users
--     LOOP
--         -- Step 2 and 3: get the org id using app id and user id
--         WITH app AS (
--             SELECT * 
--             FROM apps
--             WHERE app_id = rec.app_id
--         )
--         SELECT orgs.id 
--         INTO org_id 
--         FROM orgs, app
--         WHERE orgs.created_by = app.user_id;

--         -- Step 4: create new row in org_users with 'read' right
--         INSERT INTO org_users (user_id, org_id, app_id, channel_id, user_right) 
--         VALUES (rec.user_id, org_id, rec.app_id, rec.channel_id, 'read');
--     END LOOP;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- add function to check if user has min right
-- CREATE OR REPLACE FUNCTION check_min_rights(min_right user_min_right, user_id uuid, org_id uuid, app_id varchar, channel_id bigint)
-- RETURNS boolean AS $$
-- DECLARE
--     user_right_record RECORD;
-- BEGIN
--     FOR user_right_record IN 
--         SELECT org_users.user_right, org_users.app_id, org_users.channel_id 
--         FROM org_users 
--         WHERE org_users.org_id = check_min_rights.org_id AND org_users.user_id = check_min_rights.user_id
--     LOOP
--         IF (user_right_record.user_right >= min_right AND user_right_record.app_id IS NULL AND user_right_record.channel_id IS NULL) OR
--            (user_right_record.user_right >= min_right AND user_right_record.app_id = check_min_rights.app_id AND user_right_record.channel_id IS NULL) OR
--            (user_right_record.user_right >= min_right AND user_right_record.app_id = check_min_rights.app_id AND user_right_record.channel_id = check_min_rights.channel_id)
--         THEN
--             RETURN true;
--         END IF;
--     END LOOP;

--     RETURN false;
-- END;
-- $$ LANGUAGE plpgsql SECURITY DEFINER;

-- CREATE POLICY "Allow owner to all" ON "public"."orgs"
-- AS PERMISSIVE FOR ALL
-- TO authenticated
-- USING (check_min_rights('admin', uid(), id, null, null))
-- WITH CHECK (check_min_rights('admin', uid(), id, null, null))


-- CREATE POLICY "Allow owner to all" ON "public"."org_users"
-- AS PERMISSIVE FOR ALL
-- TO authenticated
-- USING (check_min_rights('admin', uid(), org_id, null, null))
-- WITH CHECK (check_min_rights('admin', uid(), org_id, null, null))
