-- Create deploy_history table
CREATE TABLE IF NOT EXISTS "public"."deploy_history" (
    "id" bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "created_at" timestamp with time zone DEFAULT NOW(),
    "updated_at" timestamp with time zone DEFAULT NOW(),
    "channel_id" bigint NOT NULL REFERENCES channels(id),
    "app_id" character varying NOT NULL REFERENCES apps(app_id),
    "version_id" bigint NOT NULL REFERENCES app_versions(id),
    "deployed_at" timestamp with time zone DEFAULT NOW(),
    "created_by" uuid NOT NULL REFERENCES public.users(id),
    "owner_org" uuid NOT NULL
);

-- Add indexes to improve query performance on deploy_history table
CREATE INDEX IF NOT EXISTS deploy_history_channel_id_idx ON "public"."deploy_history" (channel_id);
CREATE INDEX IF NOT EXISTS deploy_history_app_id_idx ON "public"."deploy_history" (app_id);
CREATE INDEX IF NOT EXISTS deploy_history_version_id_idx ON "public"."deploy_history" (version_id);
CREATE INDEX IF NOT EXISTS deploy_history_deployed_at_idx ON "public"."deploy_history" (deployed_at);

-- Add composite indexes for common query patterns
CREATE INDEX IF NOT EXISTS deploy_history_channel_app_idx ON "public"."deploy_history" (channel_id, app_id);
CREATE INDEX IF NOT EXISTS deploy_history_app_version_idx ON "public"."deploy_history" (app_id, version_id);
CREATE INDEX IF NOT EXISTS deploy_history_channel_deployed_idx ON "public"."deploy_history" (channel_id, deployed_at);

-- Set created_by for channels where it's NULL
UPDATE public.channels
SET created_by = (
    SELECT o.created_by
    FROM orgs o
    WHERE o.id = channels.owner_org
)::uuid
WHERE created_by IS NULL;

-- Make sure created_by in channels is not NULL
ALTER TABLE IF EXISTS "public"."channels" 
    ALTER COLUMN "created_by" SET NOT NULL;

-- Add RLS policies
ALTER TABLE "public"."deploy_history" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow users to view deploy history for their org" ON "public"."deploy_history"
FOR SELECT
USING (
    auth.uid() IN (
        SELECT user_id FROM org_users WHERE org_id = owner_org
    )
);

CREATE POLICY "Prevent update on deploy history" ON "public"."deploy_history"
FOR UPDATE
USING (false)
WITH CHECK (false);

CREATE POLICY "Allow users with write permissions to insert deploy history" ON "public"."deploy_history"
FOR INSERT
WITH CHECK (false);

CREATE POLICY "Deny delete on deploy history" ON "public"."deploy_history"
FOR DELETE
USING (false);

-- Initialize deploy_history with current versions for existing channels
INSERT INTO public.deploy_history (
    channel_id,
    app_id,
    version_id,
    owner_org,
    deployed_at,
    created_by
)
SELECT 
    c.id,
    c.app_id,
    c.version,
    c.owner_org,
    c.updated_at,
    c.created_by
FROM 
    public.channels c
WHERE 
    c.version IS NOT NULL
ON CONFLICT DO NOTHING;

-- Create function to record deployment history
CREATE OR REPLACE FUNCTION public.record_deployment_history()
RETURNS TRIGGER
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $function$
BEGIN
    -- If version is changing, record the deployment
    IF OLD.version <> NEW.version THEN
        -- Insert new record
        INSERT INTO deploy_history (
            channel_id, 
            app_id, 
            version_id, 
            owner_org,
            created_by
        )
        VALUES (
            NEW.id,
            NEW.app_id,
            NEW.version,
            NEW.owner_org,
            coalesce(get_identity()::uuid, NEW.created_by)
        );
    END IF;
    
    RETURN NEW;
END;
$function$;

-- Create trigger to record deployment history when channel version changes
DROP TRIGGER IF EXISTS record_deployment_history_trigger ON channels;

CREATE TRIGGER record_deployment_history_trigger
AFTER UPDATE OF version ON channels
FOR EACH ROW
EXECUTE FUNCTION record_deployment_history();


-- Make the function only accessible to postgres
REVOKE ALL ON FUNCTION public.record_deployment_history() FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.record_deployment_history() TO postgres;

